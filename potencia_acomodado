import matplotlib
import matplotlib.pyplot as plt 
import tensorflow as tf
import numpy as np






def generar_codigo_matlab(nombre_archivo='grafico_datos'):
    
    # Crear el contenido del archivo .m
    contenido_m = f"""
    % Archivo de script para graficar en MATLAB

    % Cargar datos desde el archivo
    datos = load('datos_mat.txt');

    % Separar datos_x y datos_y
    datos_x = datos(:, 1);
    datos_y = datos(:, 2);

    %Graficar
    figure;
    plot(datos_x);
    figure;
    plot(datos_y);
    figure;
    hold on;
    plot(datos_x);
    plot(datos_y);



    """

    # Guardar el contenido en un archivo .m
    with open(f"{nombre_archivo}.m", "w", encoding="utf-8") as archivo_matlab:
        archivo_matlab.write(contenido_m)




datos_despues_coma = []

try:
    with open('datos.txt', 'r') as archivo:
        lineas = archivo.readlines()  # Lee todas las líneas del archivo y las almacena en una lista
        
        # Procesar cada línea para obtener los datos antes y después de la coma:
        for linea in lineas:
            partes = linea.split(',')  # Divide la línea en función de la coma
            if len(partes) == 2:  # Asegurarse de que haya dos partes (antes y después de la coma)
                dato_despues_de_coma = float(partes[1].strip())  # Obtiene la parte después de la coma y elimina espacios en blanco
                datos_despues_coma.append(dato_despues_de_coma)
                
except FileNotFoundError:
    print("El archivo no se encontró")
except IOError:
    print("Ocurrió un error al leer el archivo")

        
########################################
#LEVANTE DE DATOS FIN
#######################################

maximo_valor = max(datos_despues_coma)
print(maximo_valor)

numeros_despues_coma_normalizados = [valor / maximo_valor for valor in datos_despues_coma]

############################################
# MODELO
##########################################

np.random.seed(0)
tf.random.set_seed(0)

datos = np.array(numeros_despues_coma_normalizados, dtype=float)
eje_x_mediciones = np.arange(0, len(numeros_despues_coma_normalizados))


# Definir el modelo secuencial
modelo = tf.keras.Sequential()

# Agregar la primera capa oculta
modelo.add(tf.keras.layers.Dense(units=128, input_shape=[1], activation='linear', kernel_initializer='he_normal'))

#relu linear tanh
modelo.add(tf.keras.layers.Dense(units=64, activation='linear'))
modelo.add(tf.keras.layers.Dense(units=1, activation='linear'))

# Resumen del modelo
modelo.summary()

modelo.compile(
    optimizer=tf.keras.optimizers.Adam(0.001),
    loss='mean_absolute_error'
    #mean_absolute_error
    #mean_squared_error
)



##
# PREDICCIONES
##

#evaluacion = modelo.evaluate(eje_x_mediciones, datos)
#print("Pérdida en datos de prueba:", evaluacion)

# Realizar predicciones en los datos de prueba

predicciones = modelo.predict(numeros_despues_coma_normalizados)

#print("primer valor")
#predicciones = predicciones * 2
#print(predicciones[0])

#print("multiplique todo por")
#print(maximo_valor)
#print("primer valor")
#predicciones = [valor * maximo_valor for valor in predicciones] #desnormalizo

#plt.plot(eje_x_mediciones, datos, label='Valores reales entrenados')
#plt.plot(eje_x_mediciones, predicciones, label='Predicciones')

#plt.xlabel("Índice de Datos")
#plt.ylabel("Valor")
#plt.legend()
#plt.title('Comparación de Predicciones en Datos de Prueba')
#plt.show()


# Guardar los datos en un archivo
np.savetxt('datos_mat.txt', np.column_stack((datos, predicciones )))
generar_codigo_matlab('mat')

